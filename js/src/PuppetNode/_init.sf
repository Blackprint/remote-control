## html
<div class="node {{ type || '' }}" style="transform: translate3d({{ x }}px, {{ y }}px, 0px)">
	<sf-template path="Blackprint/nodes/template/routes.sf"></sf-template>
	<sf-template path="Blackprint/nodes/template/header.sf"></sf-template>

	<div class="content">
		<div class="left-port">
			<sf-template path="Blackprint/nodes/template/input-port.sf"></sf-template>
		</div>
		<div class="right-port">
			<sf-template path="Blackprint/nodes/template/output-port.sf"></sf-template>
		</div>

		<div class="section-split"></div>

		<div class="container">
			<div sf-each="val in _interfaces" class="{{ val.type }}" style="display: {{ val.inline ? 'inline-block' : 'block' }}">
       		{{@exec
				if(val.label){
					if(val.inline)
						{[ <label>{{ val.label }} </label> ]};
					else
						{[ <label>{{ val.label }}: </label> ]};
				}

				if(val.type === 'text_in' || val.type === 'text_out')
					{[ <textarea style="width: 99%" placeholder="{{ val.placeholder || '' }}" title="{{ val.tooltip || '' }}"></textarea> ]};
				else if(val.type === 'picture_in')
					{[ <div class="img"><div class="label">{{ val.placeholder || "Drag and drop picture here..." }}</div><img title="{{ val.tooltip || '' }}"></img></div> ]};
				else if(val.type === 'picture_out')
					{[ <div class="img"><div class="label">{{ val.placeholder || "Picture will be displayed here..." }}</div><img title="{{ val.tooltip || '' }}"></img></div> ]};
				else if(val.type === 'checkbox_in')
					{[ <input type="checkbox" title="{{ val.tooltip || '' }}"></input> ]};
				else if(val.type === 'led_out')
					{[ <div class="led" title="{{ val.tooltip || '' }}"></div> ]};
				else if(val.type === 'dropdown_in' && val.multiple)
					{[ <select multiple title="{{ val.tooltip || '' }}"></select> ]};
				else if(val.type === 'dropdown_in' && !val.multiple)
					{[ <select title="{{ val.tooltip || '' }}"></select> ]};
				else if(val.type === 'file_in' && val.multiple)
					{[ <input type="file" multiple title="{{ val.tooltip || '' }}"></input> ]};
				else if(val.type === 'file_in' && !val.multiple)
					{[ <input type="file" title="{{ val.tooltip || '' }}"></input> ]};
				else if(val.type === 'file_out')
					{[ <button title="{{ val.tooltip || '' }}">{{ val.text || 'Download' }}</button> ]};
				else if(val.type === 'button_in')
					{[ <button title="{{ val.tooltip || '' }}">{{ val.text || 'Button' }}</button> ]};
				else throw new Error(`Type is not recognized: ${val.type}`);
			}}
			</div>
		</div>
	</div>

	<sf-template path="Blackprint/nodes/template/other.sf"></sf-template>
</div>

## scss-global
sf-space[blackprint] bpic-bpremote-PuppetNode .node {
	.container {
		text-align: center;
		max-width: 400px;
	}
	.section-split{
		width: 100%;
		height: 1px;
		padding-top: 7px;
		border-bottom: 1px dashed white;
		display: flex;
	}
	label {
		margin: 5px 5px 2px 5px;
		color: white;
		display: inline-block;
		font-size: 14px;
	}
	textarea {
		margin: 0px;
	}
	button {
		background: #0000008c;
		border: 2px solid #ffffff6b;
		margin: 3px;
		padding: 2px 8px;
		border-radius: 50px;
		outline: none;
		color: white;
		cursor: pointer;
		&:hover{
			background: #9191918c;
		}
	}
	input {
		vertical-align: middle;
	}
	.img{
		position: relative;
		margin: 0 auto;
		width: 250px;
		min-height: 100px;
		background: black;
		border-radius: 10px;
		overflow: hidden;
		.label {
			font-size: 8px;
			text-align: center;
			top: 5px;
			position: absolute;
			width: 100%;
			color: gray;
		}
	}
	img{
		height: 100%;
		max-width: 100%;
		max-height: 250px;
		text-align: center;
		visibility: hidden;
		position: relative;
		vertical-align: -webkit-baseline-middle;
		&[src]{
			visibility: visible;
		}
	}
	.text_in, .text_out, .checkbox_in, .dropdown_in, .file_in {
		text-align: left;
	}
	.checkbox_in, .dropdown_in, .file_in {
		margin: 5px 0 5px 0;
	}
	.picture_in, .picture_out {
		margin-bottom: 2px;
	}
	.picture_in, .picture_out, .file_out, .button_in {
		label{
			display: block;
		}
	}
	.led_out {
		margin: 0 3px;
		.led {
			background: gray;
			margin: 5px auto;
			height: 15px;
			width: 15px;
			border-radius: 15px;
			text-align: center;
			&.inactive { background: #c93f3f; }
			&.active { background: green; }
		}
	}
}

## js-global
Blackprint.Sketch.registerInterface("BPIC/BPRemote/PuppetNode", {
	template: #this.path,
}, class extends Blackprint._IPuppetNode {
	constructor(node){
		super(node);
		this._interfaces = {};

		// text_out, text_in, picture_out, picture_in, file_out, file_in, button_in
		this.interfaceSync = node.constructor.interfaceSync || [
			/* {type: "text_out", id: "log", placeholder: "Output log", tooltip: "aaa"},
			{type: "text_in", id: "input", placeholder: "Type text here..."},
			{type: "picture_out", id: "pic_out", tooltip: "Picture preview"},
			{type: "picture_in", id: "pic_in", tooltip: "Picture input"},
			{type: "checkbox_in", id: "checkbox_in", tooltip: "Enable/disable"},
			{type: "led_out", id: "led_out", tooltip: "Status indicator", inline: true},
			{type: "dropdown_in", id: "dropdown_in", tooltip: "List selection", options: [
				{id: 'aa', text: 'AA'},
				{id: 'bb', text: 'BB'},
			], multiple: false},
			{type: "file_in", id: "file_in", tooltip: "File input"},
			{type: "file_out", id: "file_out", tooltip: "File download", inline: true},
			{type: "button_in", id: "button_in", tooltip: "Button input", inline: true}, */
		];
	}
	init(){
		let sync = this.interfaceSync;
		let _interfaces = this._interfaces;

		for (let i=0; i < sync.length; i++) {
			let temp = sync[i];
			if(!temp.id) throw new Error("Every 'interfaceSync' require an 'id', but one of the interface haven't been specified yet");

			sf.Obj.set(_interfaces, temp.id, temp);

			if(temp.type === 'text_in'){
				_interfaces.$el('textarea', temp.id).on('input', ev => {
					this.syncOut(temp.id, ev.target.value);
				});
			}
			else if(temp.type === 'picture_in'){
				let el = _interfaces.$el('.img', temp.id);
				el.on('dragover', ev => ev.preventDefault());
				el.on('drop', ev => {
					ev.preventDefault();

					let file = ev.dataTransfer.files[0];
					if(!(file instanceof File))
						throw new Error("Dropped item in this element was not a file");

					this._encodeFile(file).then(v => {
						this.syncOut(temp.id, { url: 'data:image;base64,'+btoa(v) });
					});

					let FR = new FileReader();
					FR.addEventListener("load", ev => el.find('img')[0].src = ev.target.result); 
					FR.readAsDataURL(file);
				});
			}
			else if(temp.type === 'checkbox_in'){
				_interfaces.$el('input', temp.id).on('input', ev => {
					this.syncOut(temp.id, ev.target.checked);
				});
			}
			else if(temp.type === 'dropdown_in'){
				let el = _interfaces.$el('select', temp.id);
				el.on('input', ev => {
					this.syncOut(temp.id, {selected: [...ev.target.selectedOptions].map(v => v.value)});
				});

				let options = temp.options;
				for (let i=0; i < options.length; i++) {
					let item = options[i];
					el.append(`<option value="${$.escapeText(item.id)}">${$.escapeText(item.text)}</option>`);
				}
			}
			else if(temp.type === 'file_in'){
				_interfaces.$el('input', temp.id).on('input', ev => {
					Promise.all([...ev.target.files].map(v => this._encodeFile(v))).then(v => {
						this.syncOut(temp.id, { data: v });
					});
				});
			}
			else if(temp.type === 'file_out'){
				let el = _interfaces.$el('button', temp.id);
				el.on('click', ev => {
					let fileData = el[0].fileData;
					if(fileData == null)
						throw new Error("No downloadable content");

					let blob = new Blob([fileData], { type: 'application/octet-stream' });

					let temp = document.createElement('a');
					temp.href = URL.createObjectURL(blob);
					temp.download = temp.filename || 'file';
					temp.style = 'display:none';
					document.body.appendChild(temp);
					temp.target = '_blank';
					temp.click();
					temp.remove();

					setTimeout(()=> URL.revokeObjectURL(temp.href), 10000);
				});
			}
			else if(temp.type === 'button_in'){
				_interfaces.$el('button', temp.id)
					.on('pointerdown', ev => {
						this.syncOut(temp.id, {press: true});
					})
					.on('pointerup', ev => {
						this.syncOut(temp.id, {press: false});
					});
			}
		}
	}
	async _encodeFile(file){
		file = await file.arrayBuffer();

		let encoded = '';
		let bytes = new Uint8Array(file);

		for (let i = 0, n = bytes.byteLength; i < n; i++)
			encoded += String.fromCharCode(bytes[i]);

		return encoded;
	}
	syncIn(id, data){
		let item = this._interfaces[id];
		if(item == null) return; // Skip node data sync from remote

		if(item.type === 'text_out')
			this._interfaces.$el('textarea', id).val(data);
		else if(item.type === 'picture_out')
			this._interfaces.$el('img', id).attr('src', data.url);
		else if(item.type === 'checkbox_in')
			this._interfaces.$el('input', id)[0].checked = data.active;
		else if(item.type === 'dropdown_in'){
			if(data.type === 'list'){
				let el = this._interfaces.$el('select', id);
				el[0].textContent = '';

				let options = data.options;
				for (let i=0; i < options.length; i++) {
					let item = options[i];
					el.append(`<option value="${$.escapeText(item.id)}">${$.escapeText(item.text)}</option>`);
				}
			}
			else if(data.type === 'selected'){
				let el = this._interfaces.$el('select', id);
				let list = el.find('option');
				let index = -1;

				for (let i=0; i < list.length; i++) {
					if(list[i].value === data.id){
						index = i;
						break;
					}
				}

				if(index === -1)
					return console.error(`Id "${data.id}" was not found in dropdown "${id}" list on node "${this.iface.namespace}"`);

				el[0].selectedIndex = index;
			}
		}
		else if(item.type === 'led_out'){
			let div = this._interfaces.$el('div', id);
			div.removeClass(data.active ? 'inactive' : 'active');
			div.addClass(data.active ? 'active' : 'inactive');
		}
		else if(item.type === 'file_out'){
			let temp = data.data;
			let bytes = new Uint8Array(temp.length);
			for (var i = 0; i < temp.length; i++)
				bytes[i] = temp.charCodeAt(i);

			this._interfaces.$el('button', id)[0].fileData = bytes;
		}
	}
	syncOut(id, data){ this.node.syncOut(id, data) }
});